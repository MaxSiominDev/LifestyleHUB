# Функционал приложения
Приложение состоит из 3 основных экранов (```TLD```) (другие - дополнительные к ним) - Home, Planner, Profile.
## ВАЖНО!
Пожалуйста, создайте релизную сборку приложения и тестите на ней. Debug подлагивает, но это норма. В релизе все летает
Пожалуйста, если есть возможность, тестируйте на английском (хоть и есть перевод на русский, но на английском выглядит круче)
Пожалуйста, простите если написан бредовый код, я 2 дня пишу это с температурой 39
## Home
Состоит из 4 экранов - Home, AddPlan, Photo, Details
### Home
Здесь у пользователя запрашивается ```Location Permission```. 
На этом экране пользователь видит погоду, а также места рядом через ```Places API```. 
При загрузке фотографии для ```Place``` обеспечен ```Shimmer effect``` серого цвета.
 В случае, если места еще не загружены, или не могут быть загружены по какой-то причине, отображается текст с сообщением об этом. 
 Виджет погоды имеет 3 состояния:
- ```Loading``` - отображается ```Shimmer effect``` голубого цвета.
- ```Error``` - по какой-либо причине не удалось загрузить данные о погоде, отображается виджет погоды с прочерками (```–```).
- ```Success``` - погода загружена, отображается название места (город/район/местность/etc), реальная температура, минимальная и максимальная температура дня, температура по ощущениям, иконка погоды, название погоды (дождь, снег, etc).

В ТЗ давалась идея заранее сохранить картинки в приложение и не подгружать их, я отказался от этого по следующим причинам:
- Со временем OpenWeatherAPi может отдавать другие иконки.
- Некоторые иконки могут никогда не пригодиться пользователю, при этом они всё равно будут занимать место в APK файле.

На экране реализован Pull To Refresh для повторной загрузки мест поблизости и погоды.
Виджет погоды можно скрыть.
Лента может состоять из разных элементов, например, погода - тоже элемент ленты.
Если изображение какого-то место не может быть загружено, отображается ```placeholder```.
Есть возможность из общего списка мест добавить план
### Add Plan
Здесь пользователь может создать новый план (досуг). Он выбирает место досуга, дату, название досуга и комментарий к нему
### Details
Подробная информация о конкретном месте. Можно перейти по email, телефону и сайту. Можно добавить место в досуг (планы)
### Photo
Если нажать на фотографию места, она открывается на полный экран в Photo Screen

## Planner
Состоит из 2 экранов - Planner, EditPlan
### Planner Screen
Список всех планов на данный момент. Есть PullToRefresh
### Edit Plan
Можно перейти на конкретный план из Planner Screen чтобы увидеть его детали и отредактировать

## Auth
Состоит из 5 экранов - Profile, Auth, Login, Signup, SuccessfulRegistration:
### Profile Screen
Первый экран, Auth TLD. Если вход выполнен, отображается юзернейм, имя и аватарка пользователя. Если не выполнен, сразу открывается ```Auth Screen```. Предусмотрена кнопка выхода из аккаунта.
### Auth Screen
Пользователю дается выбор: войти или зарегистрироваться.
### Signup Screen
Пользователь вводит юзернейм и пароль, а с ```randomuser api``` подтягивается имя и аватарка. Если юзернейм и пароль проходят валидацию (по длине, по сложности, по незанятости), и api возвращает корректный ```response```, то через ```Authlib``` (см. ниже) производится регистрация пользователя и сохраняется в ```Room DB```
Если ввести юзернейм ```rokymiel```, то на экране появится анимация фейерверков (с любовью для Михаила Кузнецова, покажите ему, пожалуйста, Миша лучший!!!).
### Successful Registration Screen
Благодарность пользователю за регистрацию, кнопка войти, которая отправляет на ```Login Screen```, чтобы войти в только что созданный аккаунт.
### Login Screen
Можно войти по юзернейму и паролю, после входа возвращает на Profile Screen.

# Навигация в проекте

Есть 3 ```Top level destinations (TLDs)```, в них свои отдельные бэкстеки, при навигации между TLD, состояние всех TLD сохраняется
В Auth своя логика навигации. При переходе между ```Login Screen``` и ```Signup Screen```, вызывается ```popBackStack()``` (смотрите в коде). В ```Auth Screen``` есть бэкхендлер, который не дает пользователю вернуться на ```Profile Screen```, и возвращает сразу в ```Home TLD```.

# Кеширование
Я не кеширую запросы на получение погоды и списка мест, тк они зависят от локации, а она меняется. При этом я кеширую запрос get place details, срок валидности кеша - 6 часов

# Authlib
В отдельном модуле лежит библиотека ```Authlib``` - полностью автономное решение для управления учетными записями пользователей. Пользователи сохраняются в базу данных (```Room```)
Пароли хранятся в хэшированном виде.

# Используемые технологии
###  Ktor Client
Сетевые запросы через Ktor. Удобная библиотека, кроме того написала полностью на Kotlin, и не использует кодогенерацию. Красота! Есть поддержка мультиплатформы
### Dagger Hilt
Я использовал Hilt, потому что код становится чище, чем при ```Manual DI```. Кроме того, Hilt здорово экономит время разработчика (=деньги компании в реальном проекте). Не вижу ни одной причины его не использовать
Оговорка: в ```Authlib``` организован ```Manual DI``` без библиотек, чтобы показать что я умею делать DI без библиотек, и чтобы ```Authlib```. которая по задумке может быть использована в других проектах, не тянула с собой Hilt в эти проекты.
### RoomDB
Ну не вручную же пользователей было сохранять)) Вот и использовал Room. Почему не Realm? Я его пробовал в другом проекте, мне вообще не понравился, Room Forever!

### Lottie 
Анимация салютов для Михаила через Lottie. Самое удобное решение для кастомных анимаций.

### Coil
Только не говорите что надо было писать кастомный загрузчик картинок) Самое простое и оптимальное решение - Coil (тем более принцип KISS, которому нужно придерживаться по ТЗ).
### Timber
Дефолт библиотека для логирования, я к ней привык, не вижу смысла не использовать.
### Kotlinx Serialization
Все библиотеки для парсинга JSON +- одинаковые, а эта ещё и поддерживает мультиплатформу. Выбор очевиден.
### Coroutines
Мой проект использует Jetpack Compose, и странно было бы использовать для него RxJava. Мой выбор - Flows и Сoroutines
### Compose
Современная декларативная верстка намного удобнее и проще, чем Views. Я умею писать и на Views и на Compose, но при создании нового проекта выбор всегда очевиден - Compose

# Архитектура
Приложение многомодульное. Архитектура - MVI, я считаю что в большинсте случаев Compose приложения лучше писать на MVI, чем на MVVM.
Деление по модулям следующее:
- ```:app``` - модуль, где точка входа в приложение (зависиот от :core, :authlib, :navdestinations, :feature:weather, :feature:venues, :feature:auth)
- ```:core``` - общая логика в приложении (зависит от :authlib)
- ```:authlib``` - независимый модуль авторизации, готов к использованию в другом приложении (не зависит ни от чего)
- ```:feature:venues``` - логика всего, что связано с ```Venues``` - ```Home``` и ```Planner``` Screens (зависит от :core, :navdestinations, :feature:weather)
- ```:feature:weather``` логика погоды (зависит от :core)
- ```:feature:auth``` - логика всего, что связано с аккаунтом пользователя (под капотом используется :authlib), зависит от :core, :authlib и :navdestinations
- ```:navdestinations``` - вспомогательный модуль для навигации, от которого зависят все модули, где используется навигация

Может показаться неправильным, что :feature:venues зависит от :feature:weather, но я считаю это самое оптимальное решение. Weather не имеет своей навигации, и по сути представляет с собой UI + запросы в сети, так что я вынес в отдельный модуль, и этот виджет можно переиспользовать в будущем в других модулях
