# Функционал приложения
Приложение состоит из 3 основных экранов (```TLD```) (другие - дополнительные к ним) - Home, Planner, Profile.
## Home
Здесь у пользователя запрашивается ```Location Permission```. 
На этом экране пользователь видит погоду, а также места рядом через ```Places API```. 
При загрузке фотографии для ```Place``` обеспечен ```Shimmer effect``` серого цвета.
 В случае, если места еще не загружены, или не могут быть загружены по какой-то причине, отображается текст с сообщением об этом. 
 Виджет погоды имеет 3 состояния:
- ```Loading``` - отображается ```Shimmer effect``` голубого цвета.
- ```Error``` - по какой-либо причине не удалось загрузить данные о погоде, отображается виджет погоды с прочерками (```–```).
- ```Success``` - погода загружена, отображается название места (город/район/местность/etc), реальная температура, минимальная и максимальная температура дня, температура по ощущениям, иконка погоды, название погоды (дождь, снег, etc).

В ТЗ давалась идея заранее сохранить картинки в приложение и не подгружать их, я отказался от этого по следующим причинам:
- Со временем OpenWeatherAPi может отдавать другие иконки.
- Некоторые иконки могут никогда не пригодиться пользователю, при этом они всё равно будут занимать место в APK файле.

На экране реализован Pull To Refresh для повторной загрузки мест поблизости и погоды.
Виджет погоды можно скрыть.
Лента может состоять из разных элементов, например, погода - тоже элемент ленты.
Если изображение какого-то место не может быть загружено, отображается ```placeholder```.

## Planner
Пока здесь пусто

## Auth
Состоит из 5 экранов - Profile, Auth, Login, Signup, SuccessfulRegistration:
### Profile Screen
Первый экран, Auth TLD. Если вход выполнен, отображается юзернейм, имя и аватарка пользователя. Если не выполнен, сразу открывается ```Auth Screen```. Предусмотрена кнопка выхода из аккаунта.
### Auth Screen
Пользователю дается выбор: войти или зарегистрироваться.
### Signup Screen
Пользователь вводит юзернейм и пароль, а с ```randomuser api``` подтягивается имя и аватарка. Если юзернейм и пароль проходят валидацию (по длине, по сложности, по незанятости), и api возвращает корректный ```response```, то через ```Authlib``` (см. ниже) производится регистрация пользователя и сохраняется в ```Room DB```
Если ввести юзернейм ```rokymiel```, то на экране появится анимация фейерверков (с любовью для Михаила Кузнецова, покажите ему, пожалуйста, Миша лучший!!!).
### Successful Registration Screen
Благодарность пользователю за регистрацию, кнопка войти, которая отправляет на ```Login Screen```, чтобы войти в только что созданный аккаунт.
### Login Screen
Можно войти по юзернейму и паролю, после входа возвращает на Profile Screen.

# Навигация в проекте

Есть 3 ```Top level destinations (TLDs)```, в них свои отдельные бэкстеки, при навигации между TLD, состояние всех TLD сохраняется
В Auth своя логика навигации. При переходе между ```Login Screen``` и ```Signup Screen```, вызывается ```popBackStack()``` (смотрите в коде). В ```Auth Screen``` есть бэкхендлер, который не дает пользователю вернуться на ```Profile Screen```, и возвращает сразу в ```Home TLD```.

# Authlib
В отдельном модуле лежит библиотека ```Authlib``` - полностью автономное решение для управления учетными записями пользователей. Пользователи сохраняются в базу данных (```Room```)
Пароли хранятся в хэшированном виде.

# Используемые технологии
###  Ktor Client
Сетевые запросы через Ktor. Удобная библиотека, кроме того написала полностью на Kotlin, и не использует кодогенерацию. Красота! Есть поддержка мультиплатформы
### Dagger Hilt
Я использовал Hilt, потому что код становится чище, чем при ```Manual DI```. Кроме того, Hilt здорово экономит время разработчика (=деньги компании в реальном проекте). Не вижу ни одной причины его не использовать
Оговорка: в ```Authlib``` организован ```Manual DI``` без библиотек, чтобы показать что я умею делать DI без библиотек, и чтобы ```Authlib```. которая по задумке может быть использована в других проектах, не тянула с собой Hilt в эти проекты.
### RoomDB
Ну не вручную же пользователей было сохранять)) Вот и использовал Room. Почему не Realm? Я его пробовал в другом проекте, мне вообще не понравился, Room Forever!

### Lottie 
Анимация салютов для Михаила через Lottie. Самое удобное решение для кастомных анимаций.

### Shared Preferences
Старая добрая key value storage библиотека. Можно было использовать DataStore, но он массивнее, и для такого примитивного использования как у меня, это был бы overhead (через префы я только сохраняю имя текущего пользователя).
### Coil
Только не говорите что надо было писать кастомный загрузчик картинок) Самое простое и оптимальное решение - Coil (тем более принцип KISS, которому нужно придерживаться по ТЗ).
### Timber
Дефолт библиотека для логирования, я к ней привык, не вижу смысла не использовать.
### Kotlinx Serialization
Все библиотеки для парсинга JSON +- одинаковые, а эта ещё и поддерживает мультиплатформу. Выбор очевиден.

# Архитектура
Я написал многомодульное приложение, архитектура - MVI. Остальные решения в основном описаны выше.